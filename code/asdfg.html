<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>æ¨¡æ‹Ÿå®‡å®™ - æ˜Ÿç©ºå¯è§†åŒ–</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
    <!-- æ˜Ÿç©ºè´´å›¾çƒä½“ç”¨åˆ°çš„Three.js TextureLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/TextureLoader.js"></script>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: "å¾®è½¯é›…é»‘", "Arial", sans-serif;
        }
        
        .scene-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }
        
        #sidebar-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 280px;
            height: 100vh;
            background: rgba(30, 40, 80, 0.55);
            border-right: 2px solid rgba(60, 80, 180, 0.18);
            z-index: 1200;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 0;
            backdrop-filter: blur(18px) saturate(160%);
            border-radius: 0 24px 24px 0;
            transition: background 0.4s, box-shadow 0.4s, left 0.4s, width 0.4s;
            overflow: hidden;
            max-width: 95vw;
            min-width: 40px;
        }
        #sidebar-panel.collapsed {
            left: 0;
            width: 40px;
            min-width: 40px;
            padding: 0;
            border-radius: 0 16px 16px 0;
            overflow: visible;
        }
        #sidebar-panel .sidebar-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow-y: auto;
            padding: 18px 10px 10px 10px;
            scrollbar-width: thin;
            scrollbar-color: #6a11cb rgba(255,255,255,0.08);
        }
        
        #sidebar-panel .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }
        
        #sidebar-panel .sidebar-content::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.06);
            border-radius: 3px;
        }
        
        #sidebar-panel .sidebar-content::-webkit-scrollbar-thumb {
            background: #6a11cb;
            border-radius: 3px;
        }
        #sidebar-panel.collapsed .sidebar-content {
            display: none !important;
        }
        #sidebar-toggle-btn {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 28px;
            height: 28px;
            background: rgba(37,117,252,0.85);
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1300;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 2px 8px rgba(37,117,252,0.13);
            transition: background 0.3s;
        }
        #sidebar-panel.collapsed #sidebar-toggle-btn {
            left: 6px;
            top: 6px;
        }
        #sidebar-toggle-btn:hover {
            background: #6a11cb;
        }
        
        #sidebar-panel h4 {
            color: #fff;
            font-size: 20px;
            margin: 0 0 20px 0;
            letter-spacing: 1px;
            text-align: center;
            text-shadow: 0 4px 12px rgba(0,0,0,0.25);
            font-family: 'Segoe UI', 'å¾®è½¯é›…é»‘', Arial, sans-serif;
        }
        
        #sidebar-panel input[type="text"],
        #sidebar-panel input[type="number"] {
            background: rgba(255,255,255,0.08);
            color: #fff;
            border: 1.5px solid rgba(80,120,255,0.18);
            border-radius: 8px;
            margin-bottom: 8px;
            padding: 8px 12px;
            font-size: 14px;
            transition: border-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 2px 6px rgba(80,120,255,0.08);
        }
        
        #sidebar-panel input[type="text"]:focus,
        #sidebar-panel input[type="number"]:focus {
            outline: none;
            border-color: #6a11cb;
            box-shadow: 0 0 0 3px rgba(106, 17, 203, 0.18);
        }
        
        #sidebar-panel input[type="color"] {
            border: none;
            background: transparent;
            padding: 0;
            width: 100%;
            height: 35px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        #sidebar-panel select {
            background: rgba(255,255,255,0.08);
            color: #fff;
            border: 1.5px solid rgba(80,120,255,0.18);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(80,120,255,0.08);
        }
        
        #sidebar-panel button {
            margin-top: 6px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.25s cubic-bezier(.4,2,.6,1);
            border-radius: 12px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: #fff;
            border: none;
            cursor: pointer;
            box-shadow: 0 3px 12px rgba(106, 17, 203, 0.18);
        }
        
        #sidebar-panel button:hover {
            background: linear-gradient(135deg, #2575fc 0%, #6a11cb 100%);
            transform: translateY(-2px) scale(1.04);
            box-shadow: 0 8px 24px rgba(106, 17, 203, 0.22);
        }
        
        #sidebar-panel button:active {
            transform: scale(0.98);
        }
        
        #simulate-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            font-size: 15px !important;
            font-weight: bold !important;
            letter-spacing: 1px;
            margin-top: 16px !important;
            padding: 10px 16px !important;
            box-shadow: 0 3px 10px rgba(40, 167, 69, 0.4) !important;
        }
        
        #simulate-btn:hover {
            background: linear-gradient(135deg, #20c997 0%, #28a745 100%) !important;
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.5) !important;
        }
        
        #simulate-btn.simulating {
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%) !important;
            box-shadow: 0 3px 10px rgba(220, 53, 69, 0.4) !important;
        }
        
        #simulate-btn.simulating:hover {
            background: linear-gradient(135deg, #fd7e14 0%, #dc3545 100%) !important;
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.5) !important;
        }
        
        #planet-list {
            margin-top: 12px;
            max-height: 180px;
            overflow-y: auto;
            color: #eee;
            font-size: 14px;
            scrollbar-width: thin;
            scrollbar-color: #6a11cb rgba(255,255,255,0.08);
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            padding: 8px;
        }
        
        /* ç´§å‡‘æ¨¡å¼ - å½“æ˜Ÿä½“æ•°é‡å¤šæ—¶ */
        #planet-list.compact {
            max-height: 140px;
            font-size: 13px;
        }
        
        #planet-list.compact .planet-item {
            margin-bottom: 4px;
            padding: 6px 10px;
        }
        
        #planet-list.compact .planet-name {
            font-size: 13px;
        }
        
        #planet-list.compact .delete-btn {
            padding: 3px 8px !important;
            font-size: 11px !important;
        }
        
        #planet-list::-webkit-scrollbar {
            width: 8px;
        }
        
        #planet-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.06);
            border-radius: 4px;
        }
        
        #planet-list::-webkit-scrollbar-thumb {
            background: #6a11cb;
            border-radius: 4px;
        }
        
        #three-container {
            position: absolute;
            left: 280px;
            top: 0;
            right: 0;
            bottom: 0;
        }
        
        .section-divider {
            border: 0;
            border-top: 1px solid rgba(51, 68, 102, 0.7);
            margin: 12px 0;
        }
        
        .section-label {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
            display: block;
        }
        
        .input-group {
            margin-bottom: 12px;
        }
        
        .planet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.08);
            border-radius: 8px;
            transition: background 0.25s;
            box-shadow: 0 1px 4px rgba(106, 17, 203, 0.06);
        }
        
        .planet-item:hover {
            background: rgba(106, 17, 203, 0.13);
            box-shadow: 0 4px 16px rgba(106, 17, 203, 0.13);
        }
        
        .planet-name {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: color 0.3s ease;
            user-select: none;
        }
        
        .planet-name:hover {
            color: #6a11cb;
            text-shadow: 0 0 8px rgba(106, 17, 203, 0.5);
        }
        
        .delete-btn {
            padding: 4px 10px !important;
            font-size: 12px !important;
            margin: 0 !important;
            background: linear-gradient(135deg, #fd7e14 0%, #dc3545 100%) !important;
            border-radius: 6px !important;
            font-weight: 600;
            box-shadow: 0 1px 4px rgba(220, 53, 69, 0.13) !important;
        }
        
        .delete-btn:hover {
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%) !important;
            box-shadow: 0 4px 16px rgba(220, 53, 69, 0.18) !important;
        }
        
        .drag-hint {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 40, 80, 0.55);
            color: #fff;
            padding: 14px 22px;
            border-radius: 16px;
            font-size: 16px;
            z-index: 1000;
            backdrop-filter: blur(18px) saturate(160%);
            border: 1.5px solid rgba(80,120,255,0.18);
            box-shadow: 0 4px 16px rgba(106, 17, 203, 0.13);
            font-weight: 500;
        }
        
        @media (max-width: 800px) {
            #sidebar-panel {
                width: 220px;
            }
            #sidebar-panel.collapsed {
                left: -200px;
                width: 40px;
            }
            #three-container {
                left: 220px;
            }
        }
        
        @media (max-width: 600px) {
            #sidebar-panel {
                width: 100vw;
                height: 220px;
                bottom: 0;
                top: auto;
                left: 0;
                border-radius: 0 0 24px 24px;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                max-width: 100vw;
            }
            #sidebar-panel.collapsed {
                left: 0;
                width: 40px;
                min-width: 40px;
                height: 40px;
                border-radius: 0 0 16px 16px;
            }
            #three-container {
                left: 0;
                bottom: 220px;
            }
            .drag-hint {
                top: auto;
                bottom: 220px;
            }
        }
    </style>
</head>
<body>
    <div class="scene-transition" id="scene-transition"></div>
    
    <div class="drag-hint">
        ğŸ’¡ 3Dæ‹–æ‹½æ˜Ÿä½“å¯è°ƒæ•´è½¨é“ (æœ€å¤§8000å•ä½) | æ»šè½®ç¼©æ”¾ | å³é”®æ—‹è½¬è§†è§’
    </div>
    
    <div style="display:flex;flex-direction:row;height:100vh;width:100vw;">
        <div id="sidebar-panel">
            <button id="sidebar-toggle-btn" title="æ”¶èµ·/å±•å¼€ä¾§è¾¹æ ">â®œ</button>
            <div class="sidebar-content">
                <h4>ğŸŒŒ æ˜Ÿä½“ç®¡ç†ä¸­å¿ƒ</h4>
                <div style="display:flex;gap:8px;margin-bottom:10px;">
                    <button id="change-g-btn" style="flex:1;">ä¿®æ”¹å¼•åŠ›å¸¸æ•°G</button>
                    <button id="toggle-names-btn" style="flex:1;">æ˜¾ç¤ºæ˜Ÿä½“åç§°</button>
                </div>
                <div style="display:flex;gap:8px;margin-bottom:10px;">
                    <button id="toggle-trajectories-btn" style="flex:1;">éšè—è½¨è¿¹çº¿</button>
                </div>
                
                <!-- åˆ é™¤æ·»åŠ å¤ªé˜³ç³»æ˜Ÿä½“æ¨¡å— -->
                <!--
                <div class="input-group">
                    <label class="section-label">æ·»åŠ å¤ªé˜³ç³»æ˜Ÿä½“</label>
                    <select id="solar-planet-select" style="width:100%;margin-bottom:8px;">
                        <option value="">è¯·é€‰æ‹©æ˜Ÿä½“</option>
                        <option value="å¤ªé˜³">â˜€ï¸ å¤ªé˜³</option>
                        <option value="æ°´æ˜Ÿ">â˜¿ æ°´æ˜Ÿ</option>
                        <option value="é‡‘æ˜Ÿ">â™€ é‡‘æ˜Ÿ</option>
                        <option value="åœ°çƒ">ğŸŒ åœ°çƒ</option>
                        <option value="æœˆçƒ">ğŸŒ™ æœˆçƒ</option>
                        <option value="ç«æ˜Ÿ">â™‚ ç«æ˜Ÿ</option>
                        <option value="æœ¨æ˜Ÿ">â™ƒ æœ¨æ˜Ÿ</option>
                        <option value="åœŸæ˜Ÿ">â™„ åœŸæ˜Ÿ</option>
                        <option value="å¤©ç‹æ˜Ÿ">â™… å¤©ç‹æ˜Ÿ</option>
                        <option value="æµ·ç‹æ˜Ÿ">â™† æµ·ç‹æ˜Ÿ</option>
                    </select>
                    <button id="add-solar-planet-btn" style="width:100%;">æ·»åŠ æ˜Ÿä½“</button>
                </div>
                -->
                
                <hr class="section-divider">
                
                <div class="input-group">
                    <label class="section-label">å¤©ä½“åŠå¾„ç¼©æ”¾</label>
                    <div style="display:flex;gap:8px;">
                        <input id="radius-scale-input" type="number" min="0.01" max="10" step="0.01" value="1" style="flex:1;" />
                        <button id="apply-radius-scale-btn" style="width:60px;margin:0;">åº”ç”¨</button>
                    </div>
                </div>
                
                <div class="input-group">
                    <label class="section-label">è‡ªå®šä¹‰æ˜Ÿä½“</label>
                    <input id="custom-planet-name" type="text" placeholder="æ˜Ÿä½“åç§°" style="width:100%;" />
                    <input id="custom-planet-distance" type="number" min="10" max="8000" value="100" placeholder="è½¨é“åŠå¾„" style="width:100%;" />
                    <input id="custom-planet-size" type="number" min="1" max="50" value="5" placeholder="æ˜Ÿä½“å¤§å°" style="width:100%;" />
                    <input id="custom-planet-mass" type="number" min="0.0001" max="1000000" value="1" placeholder="è´¨é‡ (10^24 kg)" style="width:100%;" />
                    <div style="display:flex;gap:6px;margin-bottom:8px;">
                        <input id="custom-planet-vx" type="number" step="0.01" value="0" placeholder="vx" style="width:33%;" />
                        <input id="custom-planet-vy" type="number" step="0.01" value="0" placeholder="vy" style="width:33%;" />
                        <input id="custom-planet-vz" type="number" step="0.01" value="0" placeholder="vz" style="width:33%;" />
                    </div>
                    <div style="display:flex;gap:6px;margin-bottom:8px;">
                        <input id="custom-planet-y" type="number" step="1" value="0" placeholder="Yé«˜åº¦" style="width:33%;" />
                        <input id="custom-planet-elevation" type="number" step="0.01" value="0" placeholder="é«˜åº¦æ¯”ä¾‹" style="width:66%;" />
                    </div>
                    <input id="custom-planet-color" type="color" value="#ff9900" />
                    <button id="add-custom-planet-btn" style="width:100%;">æ·»åŠ è‡ªå®šä¹‰æ˜Ÿä½“</button>
                </div>
                
                <hr class="section-divider">
                
                <div>
                    <label class="section-label">å·²æ·»åŠ æ˜Ÿä½“ <span id="planet-count" style="color:#6a11cb;font-size:12px;margin-left:8px;">(0ä¸ª)</span></label>
                    <div id="planet-list"></div>
                </div>
                
                <button id="simulate-btn" style="width:100%;">ğŸš€ å¼€å§‹æ¨¡æ‹Ÿ</button>
            </div>
        </div>
        
        <div id="three-container"></div>
    </div>

    <!-- æ—¶é—´æµé€æ§åˆ¶æ¨¡å—ï¼Œå±…ä¸­æ‚¬æµ® -->
    <div id="time-control-panel">
        <span id="time-label">æ—¶é—´æµé€é€Ÿåº¦: 1x</span>
        <input id="time-slider" type="range" min="0.1" max="10" step="0.1" value="1" />
    </div>
    


    <script>
        const solarSystemModels = {
            "å¤ªé˜³":   "src/models/sun.glb",
            "æ°´æ˜Ÿ":   "src/models/mercury.glb",
            "é‡‘æ˜Ÿ":   "src/models/venus.glb",
            "åœ°çƒ":   "src/models/earth.glb",
            "æœˆçƒ":   "src/models/moon.glb",
            "ç«æ˜Ÿ":   "src/models/mars.glb",
            "æœ¨æ˜Ÿ":   "src/models/jupiter.glb",
            "åœŸæ˜Ÿ":   "src/models/saturn.glb",
            "å¤©ç‹æ˜Ÿ": "src/models/uranus.glb",
            "æµ·ç‹æ˜Ÿ": "src/models/neptune.glb"
        };

        // çœŸå®åŠå¾„ï¼ˆå•ä½ï¼škmï¼‰
        const realRadius = {
            "å¤ªé˜³": 696340,
            "æ°´æ˜Ÿ": 2439.7,
            "é‡‘æ˜Ÿ": 6051.8,
            "åœ°çƒ": 6371,
            "ç«æ˜Ÿ": 3389.5,
            "æœ¨æ˜Ÿ": 69911,
            "åœŸæ˜Ÿ": 58232,
            "å¤©ç‹æ˜Ÿ": 25362,
            "æµ·ç‹æ˜Ÿ": 24622,
            "æœˆçƒ": 1737.1
        };
        
        // çœŸå®è½¨é“åŠå¾„ï¼ˆå•ä½ï¼šç™¾ä¸‡kmï¼Œæ—¥å‡è·ç¦»ï¼‰
        const realDistance = {
            "æ°´æ˜Ÿ": 57.9,
            "é‡‘æ˜Ÿ": 108.2,
            "åœ°çƒ": 149.6,
            "ç«æ˜Ÿ": 227.9,
            "æœ¨æ˜Ÿ": 778.6,
            "åœŸæ˜Ÿ": 1433.5,
            "å¤©ç‹æ˜Ÿ": 2872.5,
            "æµ·ç‹æ˜Ÿ": 4495.1,
            "æœˆçƒ": 0.384
        };
        
        // çœŸå®è´¨é‡ï¼ˆå•ä½ï¼š10^24 kgï¼‰
        const realMass = {
            "å¤ªé˜³": 1989000,
            "æ°´æ˜Ÿ": 0.330,
            "é‡‘æ˜Ÿ": 4.87,
            "åœ°çƒ": 5.97,
            "ç«æ˜Ÿ": 0.642,
            "æœ¨æ˜Ÿ": 1898,
            "åœŸæ˜Ÿ": 568,
            "å¤©ç‹æ˜Ÿ": 86.8,
            "æµ·ç‹æ˜Ÿ": 102,
            "æœˆçƒ": 0.073
        };
        
        // å¯¹æ•°ç¼©æ”¾å› å­
        const sizeScale = 0.1;
        const distanceScale = 10;
        const distanceGapScale = 1.4;
        
        function logScale(val, base = 10) {
            return Math.log(val) / Math.log(base);
        }
        
        // å¤ªé˜³ç³»é»˜è®¤å‚æ•°
        const solarSystemDefaults = {
            "å¤ªé˜³":   { distance: 0,  size: logScale(realRadius["å¤ªé˜³"]) * sizeScale*4, color: 0xffde21 },
            "æ°´æ˜Ÿ":   { distance: logScale(realDistance["æ°´æ˜Ÿ"]) * distanceScale + 0 * distanceGapScale,  size: logScale(realRadius["æ°´æ˜Ÿ"]) * sizeScale, color: 0xb5b5b5 },
            "é‡‘æ˜Ÿ":   { distance: logScale(realDistance["é‡‘æ˜Ÿ"]) * distanceScale + 5 * distanceGapScale,  size: logScale(realRadius["é‡‘æ˜Ÿ"]) * sizeScale, color: 0xeccc9a },
            "åœ°çƒ":   { distance: logScale(realDistance["åœ°çƒ"]) * distanceScale + 10 * distanceGapScale,  size: logScale(realRadius["åœ°çƒ"]) * sizeScale, color: 0x5577ff },
            "æœˆçƒ":   { distance: logScale(realDistance["æœˆçƒ"]) * 2.2, size: logScale(realRadius["æœˆçƒ"]) * sizeScale * 0.5, color: 0xa7a7a7 },
            "ç«æ˜Ÿ":   { distance: logScale(realDistance["ç«æ˜Ÿ"]) * distanceScale + 15 * distanceGapScale,  size: logScale(realRadius["ç«æ˜Ÿ"]) * sizeScale, color: 0xff5500 },
            "æœ¨æ˜Ÿ":   { distance: logScale(realDistance["æœ¨æ˜Ÿ"]) * distanceScale + 100 * distanceGapScale,  size: logScale(realRadius["æœ¨æ˜Ÿ"]) * sizeScale, color: 0xb8864a },
            "åœŸæ˜Ÿ":   { distance: logScale(realDistance["åœŸæ˜Ÿ"]) * distanceScale + 200 * distanceGapScale,  size: logScale(realRadius["åœŸæ˜Ÿ"]) * sizeScale*10, color: 0xd9c078 },
            "å¤©ç‹æ˜Ÿ": { distance: logScale(realDistance["å¤©ç‹æ˜Ÿ"]) * distanceScale + 250 * distanceGapScale,  size: logScale(realRadius["å¤©ç‹æ˜Ÿ"]) * sizeScale, color: 0x88ddff },
            "æµ·ç‹æ˜Ÿ": { distance: logScale(realDistance["æµ·ç‹æ˜Ÿ"]) * distanceScale + 400 * distanceGapScale,  size: logScale(realRadius["æµ·ç‹æ˜Ÿ"]) * sizeScale, color: 0x3344cc }
        };

        // åŠå¾„ç¼©æ”¾å…¨å±€å˜é‡
        let radiusScale = 1;

        // Three.jsåŸºç¡€é…ç½®
        const container = document.getElementById("three-container");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, (window.innerWidth - 280) / window.innerHeight, 1, 20000);
        camera.position.set(0, 150, 400);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - 280, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.sortObjects = false; // ç¦ç”¨è‡ªåŠ¨æ’åºï¼Œæ‰‹åŠ¨æ§åˆ¶æ¸²æŸ“é¡ºåº
        container.appendChild(renderer.domElement);

        // çœŸå®æ˜Ÿç©ºèƒŒæ™¯çƒä½“ï¼ˆé«˜æ¸…è´´å›¾ï¼‰
        // ä½ å¯ä»¥å°† starfield.jpg ä¸‹è½½åˆ°æœ¬åœ°å¹¶æ›¿æ¢ä¸‹é¢çš„å›¾ç‰‡URL
        // æ¨èé«˜æ¸…æ˜Ÿç©ºå›¾ï¼šhttps://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/space/galaxy_starfield.png
        const starTextureUrl = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/space/galaxy_starfield.png';
        const loaderTex = new THREE.TextureLoader();
        loaderTex.load(starTextureUrl, function(texture) {
            const geometry = new THREE.SphereGeometry(8000, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide,
                depthWrite: false
            });
            const skySphere = new THREE.Mesh(geometry, material);
            skySphere.name = 'skySphere';
            scene.add(skySphere);
        });

        // è½¨é“æ§åˆ¶å™¨
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 50;
        controls.maxDistance = 8000;

        // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
        // æ›´æ˜æ˜¾çš„æ˜Ÿç©ºèƒŒæ™¯
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 8000;
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < starCount; i++) {
            const x = (Math.random() - 0.5) * 16000;
            const y = (Math.random() - 0.5) * 16000;
            const z = (Math.random() - 0.5) * 16000;
            starVertices.push(x, y, z);
            // æ˜Ÿæ˜Ÿæœ‰å†·æš–è‰²è°ƒ
            const color = new THREE.Color();
            if (Math.random() > 0.5) {
                color.setHSL(0.6 + Math.random() * 0.2, 0.7, 0.8 + Math.random() * 0.2); // è“ç™½
            } else {
                color.setHSL(0.1 + Math.random() * 0.1, 0.7, 0.9 + Math.random() * 0.1); // é»„ç™½
            }
            starColors.push(color.r, color.g, color.b);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({
            size: 2.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.95,
            depthWrite: false
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // ç¯å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.1); // æ›´äº®
        scene.add(ambientLight);

        // ç‚¹å…‰æºæ¨¡æ‹Ÿå¤ªé˜³å…‰
        const pointLight = new THREE.PointLight(0xffffff, 2.8, 16000); // æ›´äº®æ›´è¿œ
        pointLight.position.set(0, 0, 0);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // æ˜Ÿä½“åˆ—è¡¨ç®¡ç†
        const planetObjs = [];
        const planetNames = new Set();

        // åŠ è½½ç®¡ç†å™¨
        const loader = new THREE.GLTFLoader();

        // ç”¨äºè½¨é“åŠ¨ç”»æ§åˆ¶
        let isSimulating = false;
        const clock = new THREE.Clock();

        // æ‹–æ‹½ç›¸å…³å˜é‡
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedPlanet = null;
        let isDragging = false;
        let dragStart = null;
        let orbitAnimationPaused = false;
        let dragOrbitLine = null;
        let dragRadiusLabel = null;
        let dragHelperLine = null;
        let isFocusing = false; // æ·»åŠ èšç„¦åŠ¨ç”»æ ‡å¿—

        // ä¸‡æœ‰å¼•åŠ›å¸¸æ•°ï¼ˆå•ä½ï¼šåˆé€‚ç¼©æ”¾ï¼ŒThree.jså•ä½ï¼‰
        let G = 10; // æ›´å¼ºå¼•åŠ›ï¼Œä¾¿äºè§‚å¯Ÿå¸å¼•

        // è½¨è¿¹çº¿ç®¡ç†
        const trajectoryLines = new Map(); // name -> {geometry, line, positions, colors, fadeOut}
        // maxTrajectoryPoints å°¾è¿¹æ®‹ç•™æ—¶é—´ - 35ç§’
        // å‡è®¾60fpsï¼Œ35ç§’ = 2100å¸§ï¼Œè€ƒè™‘æ—¶é—´ç¼©æ”¾ï¼Œè®¾ç½®ä¸ºæ›´å¤§å€¼
        const maxTrajectoryPoints = 7000; // å»¶é•¿åˆ°35ç§’è½¨è¿¹çº¿æ—¶é—´
        const fadeOutDuration = 3000; // å»¶é•¿æ¶ˆå¤±åŠ¨ç”»æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        let showTrajectories = true; // è½¨è¿¹çº¿æ˜¾ç¤ºå¼€å…³

        // åŠ¨åŠ›å­¦æ¨¡æ‹Ÿä¸»å¾ªç¯
        function simulatePhysics(dt) {
            // 1. è®¡ç®—æ‰€æœ‰æ˜Ÿä½“çš„åˆåŠ›
            const forces = planetObjs.map(() => new THREE.Vector3(0, 0, 0));
            for (let i = 0; i < planetObjs.length; i++) {
                const pi = planetObjs[i].mesh;
                const mi = pi.userData.mass || 1;
                for (let j = 0; j < planetObjs.length; j++) {
                    if (i === j) continue;
                    const pj = planetObjs[j].mesh;
                    const mj = pj.userData.mass || 1;
                    const rij = new THREE.Vector3().subVectors(pj.position, pi.position);
                    const dist = rij.length();
                    if (dist < 1e-2) continue;
                    // ä¸‡æœ‰å¼•åŠ› F = G * m1 * m2 / r^2
                    const F = G * mi * mj / (dist * dist);
                    const forceVec = rij.clone().normalize().multiplyScalar(F);
                    forces[i].add(forceVec);
                }
            }
            
            // 2. æ›´æ–°é€Ÿåº¦å’Œä½ç½®ï¼ˆåˆ†æ­¥è¿›è¡Œï¼Œæ¯æ­¥éƒ½æ£€æŸ¥ç¢°æ’ï¼‰
            for (let i = 0; i < planetObjs.length; i++) {
                const mesh = planetObjs[i].mesh;
                if (!mesh.userData.velocity) mesh.userData.velocity = new THREE.Vector3(0, 0, 0);
                const acc = forces[i].clone().divideScalar(mesh.userData.mass || 1);
                mesh.userData.velocity.add(acc.multiplyScalar(dt));
                
                // åˆ†æ­¥ç§»åŠ¨ï¼Œæ¯æ­¥æ£€æŸ¥ç¢°æ’
                const stepCount = 5; // å°†ç§»åŠ¨åˆ†æˆ5æ­¥
                const stepDt = dt / stepCount;
                const stepVelocity = mesh.userData.velocity.clone().multiplyScalar(stepDt);
                
                for (let step = 0; step < stepCount; step++) {
                    mesh.position.add(stepVelocity);
                    
                    // æ¯æ­¥éƒ½è¿›è¡Œç¢°æ’æ£€æµ‹ï¼Œä½†éœ€è¦æ£€æŸ¥meshæ˜¯å¦è¿˜å­˜åœ¨
                    if (mesh && scene.children.includes(mesh)) {
                        const currentIndex = planetObjs.findIndex(p => p.mesh === mesh);
                        if (currentIndex !== -1) {
                            checkCollisionsInStep(mesh, currentIndex);
                        }
                    }
                }
                // è½¨è¿¹è®°å½•
                let traj = trajectoryLines.get(mesh.uuid);
                if (!traj) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = [];
                    const colors = [];
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    
                    // åˆ›å»ºæ›´ç¾è§‚çš„è½¨è¿¹çº¿æè´¨
                    const material = new THREE.LineBasicMaterial({ 
                        vertexColors: true, 
                        linewidth: 6, // æ›´ç²—çš„çº¿æ¡
                        transparent: true,
                        depthTest: false, // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿è½¨è¿¹çº¿å§‹ç»ˆå¯è§
                        depthWrite: false,
                        blending: THREE.AdditiveBlending,
                        opacity: 1.0, // æé«˜ä¸é€æ˜åº¦
                        fog: false // ç¦ç”¨é›¾æ•ˆï¼Œç¡®ä¿è½¨è¿¹çº¿ä¸å—è·ç¦»å½±å“
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    // ç¡®ä¿è½¨è¿¹çº¿å¯è§æ€§è®¾ç½®
                    line.renderOrder = 999;
                    line.frustumCulled = false;
                    line.material.needsUpdate = true;
                    
                    if (showTrajectories) {
                        scene.add(line);
                    }
                    
                    traj = { 
                        geometry, 
                        line, 
                        positions, 
                        colors,
                        fadeOut: null,
                        lastUpdateTime: Date.now()
                    };
                    trajectoryLines.set(mesh.uuid, traj);
                }
            // æ›´æ–°è½¨è¿¹çº¿ä½ç½®å’Œé¢œè‰² - å®æ—¶æ›´æ–°
            traj.positions.push(mesh.position.x, mesh.position.y, mesh.position.z);
            if (traj.positions.length > maxTrajectoryPoints * 3) traj.positions.splice(0, 3);
            
            // æ¸…é™¤ä¹‹å‰çš„é¢œè‰²æ•°ç»„
            traj.colors.length = 0;
            
            // è·å–æ˜Ÿä½“åŸºç¡€é¢œè‰²
            const baseColor = mesh.material.color ? mesh.material.color.clone() : new THREE.Color(0xffffff);
            const totalPoints = traj.positions.length / 3;
            
            // åˆ›å»ºè½¨è¿¹çº¿é¢œè‰² - ç›´æ¥å‡ºç°ï¼Œæ— æ¸å˜
            for (let k = 0; k < totalPoints; k++) {
                const c = baseColor.clone();
                
                // æ‰€æœ‰ç‚¹éƒ½ä¿æŒä¸é€æ˜ï¼Œç›´æ¥å‡ºç°
                let alpha = 1.0;
                
                // åªåœ¨æ¶ˆå¤±åŠ¨ç”»æ—¶åº”ç”¨é€æ˜åº¦
                if (traj.fadeOut) {
                    const fadeProgress = (Date.now() - traj.fadeOut.startTime) / fadeOutDuration;
                    alpha *= Math.max(0, 1 - fadeProgress);
                }
                
                traj.colors.push(c.r * alpha, c.g * alpha, c.b * alpha);
            }
            
            // æ›´æ–°å‡ ä½•ä½“
            traj.geometry.setAttribute('position', new THREE.Float32BufferAttribute(traj.positions, 3));
            traj.geometry.setAttribute('color', new THREE.Float32BufferAttribute(traj.colors, 3));
            traj.geometry.setDrawRange(0, totalPoints);
            traj.geometry.attributes.position.needsUpdate = true;
            traj.geometry.attributes.color.needsUpdate = true;
            
            // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
            traj.lastUpdateTime = Date.now();
            
            // ç¡®ä¿è½¨è¿¹çº¿å§‹ç»ˆå¯è§
            traj.line.frustumCulled = false;
            traj.line.renderOrder = 999; // ç¡®ä¿è½¨è¿¹çº¿æœ€åæ¸²æŸ“ï¼Œå§‹ç»ˆåœ¨æœ€å‰é¢
            traj.line.material.needsUpdate = true; // å¼ºåˆ¶æ›´æ–°æè´¨
            
            // å¼ºåˆ¶æ›´æ–°è½¨è¿¹çº¿å¯è§æ€§
            if (traj.line.material) {
                traj.line.material.transparent = true;
                traj.line.material.depthTest = false;
                traj.line.material.depthWrite = false;
                traj.line.material.opacity = 1.2; // ç¨å¾®è¶…è¿‡1.0ï¼Œå¢å¼ºå‘å…‰æ•ˆæœ
                traj.line.material.blending = THREE.AdditiveBlending;
                traj.line.material.linewidth = 6; // ç¡®ä¿çº¿æ¡ç²—ç»†
            }
            }
            // 3. æ£€æµ‹ç¢°æ’å¹¶åˆå¹¶ï¼ˆæ”¹è¿›çš„é«˜é€Ÿç¢°æ’æ£€æµ‹ï¼‰
            const mergePairs = [];
            const mergedIndices = new Set();
            
            // ä½¿ç”¨æ›´ç²¾ç¡®çš„ç¢°æ’æ£€æµ‹ï¼Œè€ƒè™‘é€Ÿåº¦
            for (let i = 0; i < planetObjs.length; i++) {
                if (mergedIndices.has(i)) continue;
                const pi = planetObjs[i].mesh;
                const vi = pi.userData.velocity || new THREE.Vector3();
                
                // çœŸå®åŠå¾„ï¼ˆè€ƒè™‘ç¼©æ”¾ï¼‰
                let ri = 1;
                if (pi.geometry && pi.geometry.parameters && typeof pi.geometry.parameters.radius === 'number') {
                    ri = pi.geometry.parameters.radius * (pi.scale ? pi.scale.x : 1);
                }
                
                for (let j = i + 1; j < planetObjs.length; j++) {
                    if (mergedIndices.has(j)) continue;
                    const pj = planetObjs[j].mesh;
                    const vj = pj.userData.velocity || new THREE.Vector3();
                    
                    let rj = 1;
                    if (pj.geometry && pj.geometry.parameters && typeof pj.geometry.parameters.radius === 'number') {
                        rj = pj.geometry.parameters.radius * (pj.scale ? pj.scale.x : 1);
                    }
                    
                    const dist = pi.position.distanceTo(pj.position);
                    const combinedRadius = ri + rj;
                    
                    // æ”¹è¿›çš„ç¢°æ’æ£€æµ‹ï¼šè€ƒè™‘ç›¸å¯¹é€Ÿåº¦å’Œé¢„æµ‹ç¢°æ’
                    const relativeVelocity = vi.clone().sub(vj);
                    const relativeSpeed = relativeVelocity.length();
                    
                    // è®¡ç®—ç›¸å¯¹ä½ç½®å‘é‡
                    const relativePosition = pj.position.clone().sub(pi.position);
                    
                    // é¢„æµ‹ç¢°æ’ï¼šæ£€æŸ¥ä¸‹ä¸€å¸§æ˜¯å¦ä¼šå‘ç”Ÿç¢°æ’
                    const timeStep = 0.5 * timeScale;
                    const predictedPosition1 = pi.position.clone().add(vi.clone().multiplyScalar(timeStep));
                    const predictedPosition2 = pj.position.clone().add(vj.clone().multiplyScalar(timeStep));
                    const predictedDist = predictedPosition1.distanceTo(predictedPosition2);
                    
                    // åŠ¨æ€ç¢°æ’é˜ˆå€¼ï¼šåŸºäºé€Ÿåº¦å’Œæ—¶é—´æ­¥é•¿
                    const speedFactor = Math.min(relativeSpeed * timeStep * 2, 50); // å¢åŠ é€Ÿåº¦å› å­
                    const collisionThreshold = combinedRadius + speedFactor;
                    
                    // æ£€æŸ¥å½“å‰è·ç¦»æˆ–é¢„æµ‹è·ç¦»æ˜¯å¦æ»¡è¶³ç¢°æ’æ¡ä»¶
                    if (dist < collisionThreshold || predictedDist < collisionThreshold) {
                        mergePairs.push([i, j]);
                        mergedIndices.add(i);
                        mergedIndices.add(j);
                        break; // iåªåˆå¹¶ä¸€æ¬¡
                    }
                }
            }
            // 4. ç»Ÿä¸€å¤„ç†æ‰€æœ‰åˆå¹¶
            const newPlanets = [];
            let starPlusIdx = 1;
            function getNextStarPlusName() {
                while (planetNames.has('star_plus_' + starPlusIdx)) starPlusIdx++;
                return 'star_plus_' + (starPlusIdx++);
            }
            for (const [i, j] of mergePairs) {
                const pi = planetObjs[i].mesh;
                const pj = planetObjs[j].mesh;
                const mi = pi.userData.mass || 1;
                const mj = pj.userData.mass || 1;
                const vi = pi.userData.velocity || new THREE.Vector3();
                const vj = pj.userData.velocity || new THREE.Vector3();
                const newMass = mi + mj;
                const newVel = vi.clone().multiplyScalar(mi).add(vj.clone().multiplyScalar(mj)).divideScalar(newMass);
                // ä½“ç§¯åˆå¹¶ï¼ŒåŠå¾„æŒ‰ä½“ç§¯å’Œå¼€ç«‹æ–¹
                const si = pi.geometry.parameters.radius * (pi.scale ? pi.scale.x : 1) || 1;
                const sj = pj.geometry.parameters.radius * (pj.scale ? pj.scale.x : 1) || 1;
                const newSize = Math.cbrt(si*si*si + sj*sj*sj);
                // é¢œè‰²æ··åˆ
                const ci = new THREE.Color(pi.material.color);
                const cj = new THREE.Color(pj.material.color);
                const newColor = ci.lerp(cj, mj / newMass);
                // è‡ªåŠ¨å‘½ååˆå¹¶æ˜Ÿä½“
                let mergedName = getNextStarPlusName();
                newPlanets.push({
                    name: mergedName,
                    size: newSize,
                    color: '#' + newColor.getHexString(),
                    mass: newMass,
                    velocity: newVel,
                    position: pi.position.clone().add(pj.position).multiplyScalar(0.5)
                });
            }
            // 5. ç»Ÿä¸€ç§»é™¤è¢«åˆå¹¶çš„æ˜Ÿä½“
            const indices = Array.from(mergedIndices).sort((a,b)=>b-a);
            for (const idx of indices) {
                // å¼€å§‹è½¨è¿¹çº¿æ¶ˆå¤±åŠ¨ç”»
                if (trajectoryLines.has(planetObjs[idx].mesh.uuid)) {
                    startTrajectoryFadeOut(planetObjs[idx].mesh.uuid);
                }
                
                scene.remove(planetObjs[idx].mesh);
                planetNames.delete(planetObjs[idx].name);
                removePlanetLabel(planetObjs[idx].mesh);
                planetObjs.splice(idx, 1);
            }
            // 6. ç»Ÿä¸€æ·»åŠ æ–°æ˜Ÿä½“
            for (const np of newPlanets) {
                addPlanet(np.name, 0, np.size, np.color, np.mass, false, np.velocity);
                // è®¾ç½®æ–°æ˜Ÿä½“ä½ç½®
                planetObjs[planetObjs.length-1].mesh.position.copy(np.position);
            }
            if (indices.length > 0) updatePlanetList();
        }

        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            window.addEventListener("resize", onWindowResize);
            renderer.domElement.addEventListener("pointerdown", onPointerDown);
            renderer.domElement.addEventListener("pointermove", onPointerMove);
            renderer.domElement.addEventListener("pointerup", onPointerUp);
            renderer.domElement.addEventListener("pointerleave", onPointerUp);
            renderer.domElement.addEventListener("pointercancel", onPointerUp);

            document.getElementById("add-custom-planet-btn").onclick = addCustomPlanet;
            document.getElementById("simulate-btn").onclick = toggleSimulation;
            document.getElementById("apply-radius-scale-btn").onclick = applyRadiusScale;
            document.getElementById("toggle-trajectories-btn").onclick = toggleTrajectories;

            updatePlanetList();
            animate();
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            const width = window.innerWidth - 280;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            // æ›´æ–°è½¨è¿¹çº¿ç²—ç»†
            updateTrajectoryLineWidth();
        }
        
        // æ›´æ–°è½¨è¿¹çº¿ç²—ç»†
        function updateTrajectoryLineWidth() {
            const distance = camera.position.distanceTo(controls.target);
            const lineWidth = Math.max(1, Math.min(4, 2.5 * (distance / 200))); // ä¼˜åŒ–ç²—ç»†èŒƒå›´
            
            trajectoryLines.forEach(traj => {
                if (traj.line.material) {
                    traj.line.material.linewidth = lineWidth;
                }
            });
        }
        
        // åˆ†æ­¥ç¢°æ’æ£€æµ‹å‡½æ•°
        function checkCollisionsInStep(mesh, meshIndex) {
            if (!mesh || meshIndex < 0 || meshIndex >= planetObjs.length) return;
            
            // éªŒè¯meshæ˜¯å¦ä»ç„¶å­˜åœ¨äºæ•°ç»„ä¸­
            if (planetObjs[meshIndex].mesh !== mesh) return;
            
            const ri = mesh.geometry && mesh.geometry.parameters && typeof mesh.geometry.parameters.radius === 'number' 
                ? mesh.geometry.parameters.radius * (mesh.scale ? mesh.scale.x : 1) : 1;
            
            for (let j = 0; j < planetObjs.length; j++) {
                if (j === meshIndex) continue;
                
                const otherMesh = planetObjs[j].mesh;
                if (!otherMesh) continue;
                
                const rj = otherMesh.geometry && otherMesh.geometry.parameters && typeof otherMesh.geometry.parameters.radius === 'number'
                    ? otherMesh.geometry.parameters.radius * (otherMesh.scale ? otherMesh.scale.x : 1) : 1;
                
                const dist = mesh.position.distanceTo(otherMesh.position);
                const combinedRadius = ri + rj;
                
                // æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
                if (dist < combinedRadius * 1.5) {
                    // ç«‹å³åˆå¹¶è¿™ä¸¤ä¸ªæ˜Ÿä½“
                    mergePlanets(meshIndex, j);
                    return; // é€€å‡ºæ£€æµ‹ï¼Œå› ä¸ºmeshIndexå¯èƒ½å·²ç»æ”¹å˜
                }
            }
        }
        
        // åˆå¹¶æ˜Ÿä½“å‡½æ•°
        function mergePlanets(index1, index2) {
            if (index1 >= planetObjs.length || index2 >= planetObjs.length || index1 === index2) return;
            
            const pi = planetObjs[index1].mesh;
            const pj = planetObjs[index2].mesh;
            
            if (!pi || !pj) return;
            
            const mi = pi.userData.mass || 1;
            const mj = pj.userData.mass || 1;
            const vi = pi.userData.velocity || new THREE.Vector3();
            const vj = pj.userData.velocity || new THREE.Vector3();
            
            const newMass = mi + mj;
            const newVel = vi.clone().multiplyScalar(mi).add(vj.clone().multiplyScalar(mj)).divideScalar(newMass);
            
            // ä½“ç§¯åˆå¹¶ï¼ŒåŠå¾„æŒ‰ä½“ç§¯å’Œå¼€ç«‹æ–¹
            const si = pi.geometry.parameters.radius * (pi.scale ? pi.scale.x : 1) || 1;
            const sj = pj.geometry.parameters.radius * (pj.scale ? pj.scale.x : 1) || 1;
            const newSize = Math.cbrt(si*si*si + sj*sj*sj);
            
            // é¢œè‰²æ··åˆ
            const ci = new THREE.Color(pi.material.color);
            const cj = new THREE.Color(pj.material.color);
            const newColor = ci.lerp(cj, mj / newMass);
            
            // è‡ªåŠ¨å‘½ååˆå¹¶æ˜Ÿä½“
            let starPlusIdx = 1;
            function getNextStarPlusName() {
                while (planetNames.has('star_plus_' + starPlusIdx)) starPlusIdx++;
                return 'star_plus_' + (starPlusIdx++);
            }
            const mergedName = getNextStarPlusName();
            
            // åˆ›å»ºæ–°æ˜Ÿä½“
            const newPlanet = {
                name: mergedName,
                size: newSize,
                color: '#' + newColor.getHexString(),
                mass: newMass,
                velocity: newVel,
                position: pi.position.clone().add(pj.position).multiplyScalar(0.5)
            };
            
            // ç§»é™¤æ—§æ˜Ÿä½“
            const indices = [index1, index2].sort((a, b) => b - a);
            for (const idx of indices) {
                if (trajectoryLines.has(planetObjs[idx].mesh.uuid)) {
                    startTrajectoryFadeOut(planetObjs[idx].mesh.uuid);
                }
                scene.remove(planetObjs[idx].mesh);
                planetNames.delete(planetObjs[idx].name);
                removePlanetLabel(planetObjs[idx].mesh);
                planetObjs.splice(idx, 1);
            }
            
            // ç›´æ¥åˆ›å»ºæ–°æ˜Ÿä½“ï¼Œé¿å…ä½ç½®è¢«é‡ç½®
            const geometry = new THREE.SphereGeometry(newPlanet.size * radiusScale, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: newPlanet.color,
                roughness: 0.7,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = {
                distance: 0,
                angle: 0,
                elevation: 0,
                isSolar: false,
                name: newPlanet.name,
                originalColor: newPlanet.color,
                mass: newPlanet.mass
            };
            
            // è®¾ç½®æ­£ç¡®çš„ä½ç½®å’Œé€Ÿåº¦
            mesh.position.copy(newPlanet.position);
            mesh.userData.velocity = newPlanet.velocity;
            
            scene.add(mesh);
            planetObjs.push({ mesh, name: newPlanet.name });
            planetNames.add(newPlanet.name);
            if (showPlanetNames) createPlanetLabel(mesh, newPlanet.name);
            
            updatePlanetList();
        }
        
        // å¼€å§‹è½¨è¿¹çº¿æ¶ˆå¤±åŠ¨ç”»
        function startTrajectoryFadeOut(meshUuid) {
            const traj = trajectoryLines.get(meshUuid);
            if (traj && !traj.fadeOut) {
                traj.fadeOut = {
                    startTime: Date.now()
                };
            }
        }
        
        // æ¸…ç†å·²æ¶ˆå¤±çš„è½¨è¿¹çº¿
        function cleanupFadedTrajectories() {
            const currentTime = Date.now();
            const toRemove = [];
            
            trajectoryLines.forEach((traj, meshUuid) => {
                if (traj.fadeOut) {
                    const fadeProgress = (currentTime - traj.fadeOut.startTime) / fadeOutDuration;
                    if (fadeProgress >= 1) {
                        toRemove.push(meshUuid);
                    }
                }
                
                // ç¡®ä¿è½¨è¿¹çº¿å§‹ç»ˆå¯è§
                if (traj.line && traj.line.material) {
                    traj.line.material.needsUpdate = true;
                    traj.line.material.transparent = true;
                    traj.line.material.depthTest = false;
                    traj.line.material.depthWrite = false;
                    traj.line.material.opacity = 1.2; // å¢å¼ºå‘å…‰æ•ˆæœ
                    traj.line.material.linewidth = 6; // ç¡®ä¿çº¿æ¡ç²—ç»†
                    traj.line.renderOrder = 999;
                    traj.line.frustumCulled = false;
                }
            });
            
            toRemove.forEach(meshUuid => {
                const traj = trajectoryLines.get(meshUuid);
                if (traj) {
                    scene.remove(traj.line);
                    traj.geometry.dispose();
                    traj.line.material.dispose();
                }
                trajectoryLines.delete(meshUuid);
            });
        }
        
        // è½¨è¿¹çº¿æ˜¾ç¤º/éšè—åˆ‡æ¢
        function toggleTrajectories() {
            showTrajectories = !showTrajectories;
            const btn = document.getElementById("toggle-trajectories-btn");
            btn.textContent = showTrajectories ? "éšè—è½¨è¿¹çº¿" : "æ˜¾ç¤ºè½¨è¿¹çº¿";
            
            trajectoryLines.forEach((traj, meshUuid) => {
                if (showTrajectories) {
                    if (!scene.children.includes(traj.line)) {
                        scene.add(traj.line);
                    }
                    // ç¡®ä¿è½¨è¿¹çº¿å¯è§æ€§è®¾ç½®
                    if (traj.line && traj.line.material) {
                        traj.line.material.needsUpdate = true;
                        traj.line.material.transparent = true;
                        traj.line.material.depthTest = false;
                        traj.line.material.depthWrite = false;
                        traj.line.material.opacity = 1.2; // å¢å¼ºå‘å…‰æ•ˆæœ
                        traj.line.material.linewidth = 6; // ç¡®ä¿çº¿æ¡ç²—ç»†
                        traj.line.renderOrder = 999;
                        traj.line.frustumCulled = false;
                    }
                } else {
                    if (scene.children.includes(traj.line)) {
                        scene.remove(traj.line);
                    }
                }
            });
        }
        


        // åº”ç”¨åŠå¾„ç¼©æ”¾
        function applyRadiusScale() {
            const input = document.getElementById('radius-scale-input');
            let val = parseFloat(input.value);
            if (isNaN(val) || val <= 0) {
                alert('è¯·è¾“å…¥å¤§äº0çš„ç¼©æ”¾å€æ•°');
                return;
            }
            radiusScale = val;
            
            // åˆ›å»ºä¸€ä¸ªæ›´ç°ä»£çš„æç¤º
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(37, 117, 252, 0.9);
                color: white;
                padding: 16px 24px;
                border-radius: 12px;
                font-size: 14px;
                z-index: 9999;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255,255,255,0.2);
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                animation: fadeInOut 2s ease-in-out;
            `;
            toast.textContent = `ç¼©æ”¾å€æ•°å·²è®¾ç½®ä¸º ${val}x`;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }

        // æ·»åŠ è‡ªå®šä¹‰æ˜Ÿä½“
        function addCustomPlanet() {
            const nameInput = document.getElementById("custom-planet-name");
            const distanceInput = document.getElementById("custom-planet-distance");
            const sizeInput = document.getElementById("custom-planet-size");
            const massInput = document.getElementById("custom-planet-mass");
            const vxInput = document.getElementById("custom-planet-vx");
            const vyInput = document.getElementById("custom-planet-vy");
            const vzInput = document.getElementById("custom-planet-vz");
            const yInput = document.getElementById("custom-planet-y");
            const elevationInput = document.getElementById("custom-planet-elevation");
            const colorInput = document.getElementById("custom-planet-color");

            let name = nameInput.value.trim();
            if (!name) {
                let idx = 1;
                while (planetNames.has('star_' + idx)) idx++;
                name = 'star_' + idx;
            }
            const distance = parseFloat(distanceInput.value);
            const size = parseFloat(sizeInput.value);
            const mass = parseFloat(massInput.value);
            const vx = parseFloat(vxInput.value);
            const vy = parseFloat(vyInput.value);
            const vz = parseFloat(vzInput.value);
            const y = parseFloat(yInput.value);
            const elevation = parseFloat(elevationInput.value);
            const color = colorInput.value;

            if (planetNames.has(name)) {
                alert("è¯¥æ˜Ÿä½“åç§°å·²å­˜åœ¨");
                return;
            }
            if (isNaN(distance) || distance < 10 || distance > 8000) {
                alert("è½¨é“åŠå¾„è¯·è¾“å…¥10-8000ä¹‹é—´çš„æ•°å­—");
                return;
            }
            if (isNaN(size) || size < 1 || size > 50) {
                alert("æ˜Ÿä½“å¤§å°è¯·è¾“å…¥1-50ä¹‹é—´çš„æ•°å­—");
                return;
            }
            if (isNaN(mass) || mass <= 0) {
                alert("è¯·è¾“å…¥å¤§äº0çš„è´¨é‡");
                return;
            }
            if ([vx, vy, vz, y, elevation].some(v => isNaN(v))) {
                alert("æ‰€æœ‰æ•°å€¼å¿…é¡»ä¸ºæ•°å­—");
                return;
            }

            // åˆ›å»º3Dä½ç½®
            const angle = Math.random() * Math.PI * 2;
            const finalY = y !== 0 ? y : distance * elevation;
            const position = new THREE.Vector3(
                distance * Math.cos(angle),
                finalY,
                distance * Math.sin(angle)
            );

            addPlanet(name, distance, size, color, mass, false, new THREE.Vector3(vx, vy, vz));
            
            // è®¾ç½®3Dä½ç½®
            const lastPlanet = planetObjs[planetObjs.length - 1];
            if (lastPlanet) {
                lastPlanet.mesh.position.copy(position);
            }
            
            nameInput.value = "";
            distanceInput.value = 100;
            sizeInput.value = 5;
            massInput.value = 1;
            vxInput.value = 0;
            vyInput.value = 0;
            vzInput.value = 0;
            yInput.value = 0;
            elevationInput.value = 0;
            colorInput.value = "#ff9900";
        }

        // é€šè¿‡åç§°æ·»åŠ å¤ªé˜³ç³»æ˜Ÿä½“
        function addPlanetByName(name, isSolar) {
            if (!(name in solarSystemDefaults)) {
                alert("æ— è¯¥å¤ªé˜³ç³»æ˜Ÿä½“é»˜è®¤æ•°æ®");
                return;
            }
            const def = solarSystemDefaults[name];
            const url = solarSystemModels[name];
            const scaledSize = def.size * radiusScale;
            const mass = realMass[name] || 1;
            
            if (!url) {
                addPlanet(name, def.distance, scaledSize, "#" + def.color.toString(16), mass, isSolar);
                return;
            }
            
            loader.load(url, (gltf) => {
                const mesh = gltf.scene;
                mesh.scale.set(scaledSize, scaledSize, scaledSize);
                mesh.userData = {
                    distance: def.distance,
                    angle: Math.random() * Math.PI * 2,
                    isSolar: isSolar,
                    name: name,
                    originalColor: def.color,
                    mass: mass
                };
                
                mesh.position.set(
                    def.distance * Math.cos(mesh.userData.angle), 
                    0, 
                    def.distance * Math.sin(mesh.userData.angle)
                );
                
                scene.add(mesh);
                planetObjs.push({ mesh, name });
                planetNames.add(name);
                // é»˜è®¤åˆé€Ÿåº¦ä¸º0ï¼Œä¾¿äºè§‚å¯Ÿä¸‡æœ‰å¼•åŠ›å¸å¼•
                mesh.userData.velocity = new THREE.Vector3(0, 0, 0);
                updatePlanetList();
            }, undefined, (err) => {
                console.error("åŠ è½½æ¨¡å‹å¤±è´¥:", err);
                addPlanet(name, def.distance, scaledSize, "#" + def.color.toString(16), mass, isSolar);
            });
        }

        // æ·»åŠ æ™®é€šçƒä½“æ˜Ÿä½“
        function addPlanet(name, distance, size, color, mass = 1, isSolar = false, velocity = null) {
            const geometry = new THREE.SphereGeometry(size * radiusScale, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = {
                distance: distance,
                angle: Math.random() * Math.PI * 2,
                elevation: (Math.random() - 0.5) * 0.3, // æ·»åŠ é«˜åº¦å˜åŒ–
                isSolar: isSolar,
                name: name,
                originalColor: color,
                mass: mass
            };
            
            // 3Dä½ç½®åˆå§‹åŒ–
            const elevation = mesh.userData.elevation;
            mesh.position.set(
                distance * Math.cos(mesh.userData.angle), 
                distance * elevation, // Yè½´ä½ç½®
                distance * Math.sin(mesh.userData.angle)
            );
            
            scene.add(mesh);
            planetObjs.push({ mesh, name });
            planetNames.add(name);
            mesh.userData.velocity = velocity ? velocity.clone() : new THREE.Vector3(0, 0, 0);
            if (showPlanetNames) createPlanetLabel(mesh, name);
            updatePlanetList();
        }

        // æ›´æ–°ä¾§è¾¹æ æ˜Ÿä½“åˆ—è¡¨æ˜¾ç¤º
        function updatePlanetList() {
            const list = document.getElementById("planet-list");
            list.innerHTML = "";
            
            // æ›´æ–°æ˜Ÿä½“æ•°é‡æ˜¾ç¤º
            const countElement = document.getElementById('planet-count');
            if (countElement) {
                countElement.textContent = `(${planetObjs.length}ä¸ª)`;
            }
            
            // æ ¹æ®æ˜Ÿä½“æ•°é‡å†³å®šæ˜¯å¦å¯ç”¨ç´§å‡‘æ¨¡å¼
            if (planetObjs.length > 8) {
                list.classList.add('compact');
            } else {
                list.classList.remove('compact');
            }
            
            planetObjs.forEach(({ mesh, name }, idx) => {
                const div = document.createElement("div");
                div.className = "planet-item";

                const nameSpan = document.createElement("span");
                nameSpan.className = "planet-name";
                nameSpan.textContent = name;
                nameSpan.style.cursor = "pointer"; // æ·»åŠ é¼ æ ‡æŒ‡é’ˆæ ·å¼
                nameSpan.title = "ç‚¹å‡»èšç„¦åˆ°è¯¥æ˜Ÿä½“"; // æ·»åŠ æç¤ºæ–‡å­—
                
                // ç‚¹å‡»æ˜Ÿä½“åç§°èšç„¦åˆ°è¯¥æ˜Ÿä½“
                nameSpan.onclick = (event) => {
                    event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                    focusOnPlanet(mesh);
                };

                // æ˜¾ç¤ºè´¨é‡
                const massSpan = document.createElement("span");
                massSpan.style.cssText = 'color:#b6e0ff;font-size:13px;margin-left:8px;';
                massSpan.textContent = `è´¨é‡: ${(mesh.userData.mass || 1)} Ã—10Â²â´kg`;
                
                // åœ¨ç´§å‡‘æ¨¡å¼ä¸‹è°ƒæ•´è´¨é‡æ˜¾ç¤º
                if (planetObjs.length > 8) {
                    massSpan.style.fontSize = '11px';
                    massSpan.style.marginLeft = '6px';
                }

                const delBtn = document.createElement("button");
                delBtn.className = "delete-btn";
                delBtn.textContent = "åˆ é™¤";
                delBtn.onclick = () => {
                    // å¼€å§‹è½¨è¿¹çº¿æ¶ˆå¤±åŠ¨ç”»
                    if (trajectoryLines.has(mesh.uuid)) {
                        startTrajectoryFadeOut(mesh.uuid);
                    }
                    
                    scene.remove(mesh);
                    planetObjs.splice(idx, 1);
                    planetNames.delete(name);
                    removePlanetLabel(mesh);
                    updatePlanetLabels();
                    updatePlanetList();
                    if (selectedPlanet === mesh) selectedPlanet = null;
                };

                div.appendChild(nameSpan);
                div.appendChild(massSpan);
                div.appendChild(delBtn);
                list.appendChild(div);
            });
            // æ¸…ç†æ‰€æœ‰æ— æ•ˆlabel
            updatePlanetLabels();
        }

        // æ¨¡æ‹Ÿå¼€å§‹/æš‚åœæŒ‰é’®
        function toggleSimulation() {
            const btn = document.getElementById("simulate-btn");
            if (!isSimulating) {
                if (planetObjs.length === 0) {
                    alert("è¯·å…ˆæ·»åŠ è‡³å°‘ä¸€ä¸ªæ˜Ÿä½“");
                    return;
                }
                isSimulating = true;
                btn.textContent = "â¸ï¸ æš‚åœæ¨¡æ‹Ÿ";
                btn.classList.add("simulating");
            } else {
                isSimulating = false;
                btn.textContent = "ğŸš€ å¼€å§‹æ¨¡æ‹Ÿ";
                btn.classList.remove("simulating");
            }
        }

        // ç¡®ä¿æ˜Ÿä½“å¤§å°ä¿æŒä¸º1çš„å‡½æ•°
        function ensurePlanetScale(planet) {
            if (planet && planet.scale) {
                planet.scale.set(1, 1, 1);
            }
        }
        
        // é¼ æ ‡ç‚¹å‡»é€‰æ‹©æ˜Ÿä½“
        function onPointerDown(event) {
            event.preventDefault();
            if (event.button !== 0) return;
            
            // å¦‚æœæ­£åœ¨èšç„¦åŠ¨ç”»ä¸­ï¼Œä¸å…è®¸æ‹–æ‹½
            if (isFocusing) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetObjs.map(p => p.mesh));
            
            if (intersects.length > 0) {
                selectedPlanet = intersects[0].object;
                isDragging = true;
                orbitAnimationPaused = true;
                dragStart = { x: event.clientX, y: event.clientY };
                controls.enabled = false;
                
                // è®°å½•æ‹–æ‹½å¼€å§‹æ—¶çš„åˆå§‹ä½ç½®å’Œè·ç¦»
                selectedPlanet.userData.dragOrigin = selectedPlanet.position.clone();
                selectedPlanet.userData.dragStartDistance = selectedPlanet.position.length();
                
                // é«˜äº®é€‰ä¸­çš„æ˜Ÿä½“ï¼ˆä¸æ”¹å˜å¤§å°ï¼‰
                if (selectedPlanet.material) {
                    selectedPlanet.material.emissive = new THREE.Color(0x6a11cb);
                    selectedPlanet.material.emissiveIntensity = 0.7;
                }
                // ç¡®ä¿å¤§å°ä¿æŒä¸º1
                ensurePlanetScale(selectedPlanet);
                
                // å…¶ä»–æ˜Ÿä½“åŠé€æ˜
                planetObjs.forEach(({ mesh }) => {
                    if (mesh !== selectedPlanet && mesh.material) {
                        mesh.material.transparent = true;
                        mesh.material.opacity = 0.3;
                    }
                });
                
                // æ‹–æ‹½æ—¶æ˜¾ç¤ºè½¨é“è¾…åŠ©çº¿
                if (dragOrbitLine) scene.remove(dragOrbitLine);
                dragOrbitLine = createOrbitLine3D(selectedPlanet.userData.distance);
                dragOrbitLine.material.color.set(0x6a11cb);
                dragOrbitLine.material.opacity = 0.5;
                scene.add(dragOrbitLine);
                
                // åˆ›å»ºæ‹–æ‹½è¾…åŠ©çº¿ï¼ˆä»åŸç‚¹åˆ°è¡Œæ˜Ÿçš„è¿çº¿ï¼‰
                if (dragHelperLine) scene.remove(dragHelperLine);
                const helperGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    selectedPlanet.position.clone()
                ]);
                const helperMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x6a11cb, 
                    linewidth: 2,
                    opacity: 0.6,
                    transparent: true
                });
                dragHelperLine = new THREE.Line(helperGeometry, helperMaterial);
                scene.add(dragHelperLine);
                
                // æ‹–æ‹½æ—¶æ˜¾ç¤ºå½“å‰åŠå¾„æ ‡ç­¾
                if (!dragRadiusLabel) {
                    dragRadiusLabel = document.createElement('div');
                    dragRadiusLabel.style.cssText = `
                        position: fixed; left: 50%; top: 60px; transform: translateX(-50%);
                        background: rgba(30,40,80,0.85); color: #fff; padding: 12px 24px;
                        border-radius: 12px; font-size: 16px; z-index: 9999;
                        box-shadow: 0 4px 16px rgba(106,17,203,0.2); font-weight: 600; 
                        pointer-events: none; border: 1px solid rgba(106,17,203,0.3);
                        transition: all 0.3s ease;`;
                    document.body.appendChild(dragRadiusLabel);
                }
                const pos = selectedPlanet.position;
                dragRadiusLabel.textContent = `æ‹–æ‹½ä¸­ - è·ç¦»: ${selectedPlanet.userData.distance.toFixed(1)} | (${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)})`;
                dragRadiusLabel.style.display = 'block';
                
                // æ·»åŠ æ‹–æ‹½å¼€å§‹æ—¶çš„è§†è§‰åé¦ˆ
                // ä¿å­˜å½“å‰é¢œè‰²ä½œä¸ºæ‹–æ‹½æ—¶çš„é¢œè‰²
                selectedPlanet.userData.dragColor = selectedPlanet.material.color.clone();
                selectedPlanet.userData.dragColorHex = selectedPlanet.material.color.getHexString();
                
                // ä½¿ç”¨userDataä¸­ä¿å­˜çš„åŸå§‹é¢œè‰²ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å½“å‰é¢œè‰²
                const originalColor = selectedPlanet.userData.originalColor || selectedPlanet.material.color.clone();
                selectedPlanet.userData.originalColor = originalColor;
                selectedPlanet.userData.originalColorHex = originalColor.getHexString();
                
                // è®¾ç½®æ‹–æ‹½æ—¶çš„ç´«è‰²
                selectedPlanet.material.color.setHex(0x6a11cb);
            } else {
                selectedPlanet = null;
            }
        }

        // é¼ æ ‡ç§»åŠ¨æ‹–æ‹½æ˜Ÿä½“ - é‡æ–°è®¾è®¡çš„ä¸‰ç»´æ‹–æ‹½ç³»ç»Ÿ
        function onPointerMove(event) {
            if (!isDragging || !selectedPlanet) return;

            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // è·å–å½“å‰é¼ æ ‡ä½ç½®
            raycaster.setFromCamera({ x, y }, camera);
            
            // æœ€å¤§æ‹–æ‹½è·ç¦»å’Œæœ€å°è·ç¦»çº¦æŸ
            const maxDistance = 8000;
            const minDistance = 10; // æœ€å°è·ç¦»çº¦æŸ
            
            // è·å–æ‹–æ‹½å¼€å§‹æ—¶çš„åˆå§‹è·ç¦»
            const initialDistance = selectedPlanet.userData.dragStartDistance || selectedPlanet.userData.distance || 100;
            
            // è®¡ç®—å°„çº¿ä¸ä»¥åŸç‚¹ä¸ºä¸­å¿ƒã€åˆå§‹è·ç¦»ä¸ºåŠå¾„çš„çƒé¢çš„äº¤ç‚¹
            const rayDirection = raycaster.ray.direction.clone();
            const rayOrigin = raycaster.ray.origin.clone();
            
            // çƒé¢æ–¹ç¨‹æ±‚è§£
            const sphereCenter = new THREE.Vector3(0, 0, 0);
            const a = rayDirection.dot(rayDirection);
            const b = 2 * rayDirection.dot(rayOrigin.clone().sub(sphereCenter));
            const c = rayOrigin.clone().sub(sphereCenter).dot(rayOrigin.clone().sub(sphereCenter)) - initialDistance * initialDistance;
            
            const discriminant = b * b - 4 * a * c;
            
            if (discriminant >= 0) {
                // è®¡ç®—äº¤ç‚¹
                const t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
                const t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
                
                // é€‰æ‹©æœ€è¿‘çš„äº¤ç‚¹ï¼ˆtå€¼è¾ƒå°çš„ï¼‰
                const t = Math.min(t1, t2);
                
                if (t > 0) {
                    const intersectPoint = rayOrigin.clone().add(rayDirection.clone().multiplyScalar(t));
                    
                    // é™åˆ¶åœ¨æœ€å°å’Œæœ€å¤§è·ç¦»å†…
                    const distance = intersectPoint.length();
                    let finalPosition;
                    
                    if (distance >= minDistance && distance <= maxDistance) {
                        finalPosition = intersectPoint;
                    } else if (distance < minDistance) {
                        // å¦‚æœå°äºæœ€å°è·ç¦»ï¼Œé™åˆ¶åœ¨æœ€å°è·ç¦»çš„çƒé¢ä¸Š
                        finalPosition = intersectPoint.clone().normalize().multiplyScalar(minDistance);
                    } else {
                        // å¦‚æœè¶…å‡ºæœ€å¤§è·ç¦»ï¼Œé™åˆ¶åœ¨æœ€å¤§è·ç¦»çš„çƒé¢ä¸Š
                        finalPosition = intersectPoint.clone().normalize().multiplyScalar(maxDistance);
                    }
                    
                    // åº”ç”¨å¹³æ»‘çš„ä½ç½®æ›´æ–°ï¼Œé¿å…çªç„¶è·³è·ƒ
                    const currentPos = selectedPlanet.position.clone();
                    const targetPos = finalPosition;
                    const lerpFactor = 0.8; // å¹³æ»‘å› å­
                    
                    const smoothedPosition = currentPos.lerp(targetPos, lerpFactor);
                    selectedPlanet.position.copy(smoothedPosition);
                    
                    // æ›´æ–°è·ç¦»ä¿¡æ¯
                    const newDistance = smoothedPosition.length();
                    selectedPlanet.userData.distance = newDistance;
                    
                    // æ›´æ–°è½¨é“è¾…åŠ©çº¿
                    if (dragOrbitLine) {
                        scene.remove(dragOrbitLine);
                        dragOrbitLine = createOrbitLine3D(newDistance);
                        dragOrbitLine.material.color.set(0x6a11cb);
                        dragOrbitLine.material.opacity = 0.5;
                        scene.add(dragOrbitLine);
                    }
                    
                    // æ›´æ–°æ‹–æ‹½è¾…åŠ©çº¿
                    if (dragHelperLine) {
                        scene.remove(dragHelperLine);
                        const helperGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(0, 0, 0),
                            smoothedPosition.clone()
                        ]);
                        dragHelperLine.geometry = helperGeometry;
                        scene.add(dragHelperLine);
                    }
                    
                    // æ›´æ–°è·ç¦»æ ‡ç­¾
                    if (dragRadiusLabel) {
                        const isMaxDistance = distance > maxDistance;
                        const isMinDistance = distance < minDistance;
                        const status = isMaxDistance ? ' (æœ€å¤§)' : isMinDistance ? ' (æœ€å°)' : '';
                        dragRadiusLabel.textContent = `è·ç¦»: ${newDistance.toFixed(1)}${status} | (${smoothedPosition.x.toFixed(0)}, ${smoothedPosition.y.toFixed(0)}, ${smoothedPosition.z.toFixed(0)})`;
                        dragRadiusLabel.style.background = isMaxDistance || isMinDistance ? 'rgba(220,53,69,0.85)' : 'rgba(30,40,80,0.85)';
                        dragRadiusLabel.style.borderColor = isMaxDistance || isMinDistance ? 'rgba(220,53,69,0.5)' : 'rgba(106,17,203,0.3)';
                    }
                }
            } else {
                // å¦‚æœå°„çº¿æ²¡æœ‰ä¸çƒé¢ç›¸äº¤ï¼Œä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
                // åˆ›å»ºä¸€ä¸ªä¸ç›¸æœºæ–¹å‘å‚ç›´çš„å¹³é¢
                const cameraDirection = camera.getWorldDirection(new THREE.Vector3());
                const planeNormal = cameraDirection.clone();
                const planePoint = selectedPlanet.position.clone();
                
                const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, planePoint);
                const intersect = new THREE.Vector3();
                
                if (raycaster.ray.intersectPlane(plane, intersect)) {
                    const distance = intersect.length();
                    let finalPosition;
                    
                    if (distance >= minDistance && distance <= maxDistance) {
                        finalPosition = intersect;
                    } else if (distance < minDistance) {
                        finalPosition = intersect.clone().normalize().multiplyScalar(minDistance);
                    } else {
                        finalPosition = intersect.clone().normalize().multiplyScalar(maxDistance);
                    }
                    
                    // åº”ç”¨å¹³æ»‘çš„ä½ç½®æ›´æ–°
                    const currentPos = selectedPlanet.position.clone();
                    const targetPos = finalPosition;
                    const lerpFactor = 0.8;
                    
                    const smoothedPosition = currentPos.lerp(targetPos, lerpFactor);
                    selectedPlanet.position.copy(smoothedPosition);
                    selectedPlanet.userData.distance = smoothedPosition.length();
                    
                    if (dragOrbitLine) {
                        scene.remove(dragOrbitLine);
                        dragOrbitLine = createOrbitLine3D(smoothedPosition.length());
                        dragOrbitLine.material.color.set(0x6a11cb);
                        dragOrbitLine.material.opacity = 0.5;
                        scene.add(dragOrbitLine);
                    }
                    
                    // æ›´æ–°æ‹–æ‹½è¾…åŠ©çº¿
                    if (dragHelperLine) {
                        scene.remove(dragHelperLine);
                        const helperGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(0, 0, 0),
                            smoothedPosition.clone()
                        ]);
                        dragHelperLine.geometry = helperGeometry;
                        scene.add(dragHelperLine);
                    }
                    if (dragRadiusLabel) {
                        const isMaxDistance = distance > maxDistance;
                        const isMinDistance = distance < minDistance;
                        const status = isMaxDistance ? ' (æœ€å¤§)' : isMinDistance ? ' (æœ€å°)' : '';
                        dragRadiusLabel.textContent = `è·ç¦»: ${smoothedPosition.length().toFixed(1)}${status} | (${smoothedPosition.x.toFixed(0)}, ${smoothedPosition.y.toFixed(0)}, ${smoothedPosition.z.toFixed(0)})`;
                        dragRadiusLabel.style.background = isMaxDistance || isMinDistance ? 'rgba(220,53,69,0.85)' : 'rgba(30,40,80,0.85)';
                        dragRadiusLabel.style.borderColor = isMaxDistance || isMinDistance ? 'rgba(220,53,69,0.5)' : 'rgba(106,17,203,0.3)';
                    }
                }
            }
        }

        // é¼ æ ‡æ¾å¼€ï¼Œç»“æŸæ‹–æ‹½
        function onPointerUp(event) {
            if (isDragging && selectedPlanet) {
                isDragging = false;
                orbitAnimationPaused = false;
                controls.enabled = true;
                
                // æ‹–æ‹½ç»“æŸé¢œè‰²æ¢å¤åŠ¨ç”»
                let t = 0;
                const startColor = new THREE.Color(0x6a11cb);
                
                // è·å–åŸå§‹é¢œè‰²
                let endColor;
                if (selectedPlanet.userData.originalColor) {
                    if (selectedPlanet.userData.originalColor instanceof THREE.Color) {
                        endColor = selectedPlanet.userData.originalColor.clone();
                    } else {
                        endColor = new THREE.Color(selectedPlanet.userData.originalColor);
                    }
                } else if (selectedPlanet.userData.originalColorHex) {
                    endColor = new THREE.Color(selectedPlanet.userData.originalColorHex);
                } else {
                    // å¦‚æœæ²¡æœ‰åŸå§‹é¢œè‰²ä¿¡æ¯ï¼Œä½¿ç”¨ç™½è‰²ä½œä¸ºé»˜è®¤
                    endColor = new THREE.Color(0xffffff);
                }
                
                function animateColor() {
                    t += 0.08;
                    
                    // åªæ¢å¤é¢œè‰²ï¼Œä¸æ”¹å˜å¤§å°
                    if (selectedPlanet.material) {
                        selectedPlanet.material.color.lerpColors(startColor, endColor, t);
                    }
                    
                    if (t < 1) {
                        requestAnimationFrame(animateColor);
                    } else {
                        if (selectedPlanet.material) {
                            selectedPlanet.material.color.copy(endColor);
                        }
                    }
                }
                animateColor();
                
                // æ¢å¤å‘å…‰æ•ˆæœ
                if (selectedPlanet.material) {
                    selectedPlanet.material.emissive = new THREE.Color(0x000000);
                    selectedPlanet.material.emissiveIntensity = 0;
                }
                
                // ç¡®ä¿å¤§å°ä¿æŒä¸º1
                ensurePlanetScale(selectedPlanet);
                
                // ç«‹å³æ¢å¤é¢œè‰²ï¼ˆä¸ä¾èµ–åŠ¨ç”»ï¼‰
                if (selectedPlanet.material && endColor) {
                    selectedPlanet.material.color.copy(endColor);
                }
                
                // ç¡®ä¿é¢œè‰²æ¢å¤ - å¦‚æœåŠ¨ç”»æ²¡æœ‰å®Œæˆï¼Œå¼ºåˆ¶æ¢å¤
                const planetToRestore = selectedPlanet; // ä¿å­˜å¼•ç”¨
                setTimeout(() => {
                    if (planetToRestore && planetToRestore.material) {
                        if (endColor) {
                            planetToRestore.material.color.copy(endColor);
                        } else {
                            // å¦‚æœè¿˜æ˜¯æ²¡æœ‰é¢œè‰²ï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²
                            planetToRestore.material.color.setHex(0xffffff);
                        }
                    }
                }, 100);
                
                // å…¶ä»–æ˜Ÿä½“æ¢å¤ä¸é€æ˜
                planetObjs.forEach(({ mesh }) => {
                    if (mesh !== selectedPlanet && mesh.material) {
                        mesh.material.opacity = 1.0;
                        mesh.material.transparent = false;
                    }
                });
                
                // æ‹–æ‹½ç»“æŸåé€Ÿåº¦å½’é›¶ï¼Œé¿å…æ‹–æ‹½å¸¦å…¥é€Ÿåº¦
                selectedPlanet.userData.velocity = new THREE.Vector3(0, 0, 0);
                
                // æ¸…ç†æ‹–æ‹½ç›¸å…³æ•°æ®
                delete selectedPlanet.userData.dragOrigin;
                delete selectedPlanet.userData.dragStartDistance;
                delete selectedPlanet.userData.dragColor;
                delete selectedPlanet.userData.dragColorHex;
                // æ³¨æ„ï¼šä¸è¦åˆ é™¤originalColorï¼Œè¿™æ˜¯æ˜Ÿä½“çš„åŸå§‹é¢œè‰²
                
                // ç§»é™¤è½¨é“è¾…åŠ©çº¿
                if (dragOrbitLine) {
                    scene.remove(dragOrbitLine);
                    dragOrbitLine = null;
                }
                
                // ç§»é™¤æ‹–æ‹½è¾…åŠ©çº¿
                if (dragHelperLine) {
                    scene.remove(dragHelperLine);
                    dragHelperLine = null;
                }
                
                // éšè—åŠå¾„æ ‡ç­¾
                if (dragRadiusLabel) {
                    dragRadiusLabel.style.display = 'none';
                    dragRadiusLabel.style.background = 'rgba(30,40,80,0.85)';
                    dragRadiusLabel.style.borderColor = 'rgba(106,17,203,0.3)';
                }
                
                selectedPlanet = null;
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // æ˜Ÿç©ºèƒŒæ™¯ç¼“æ…¢æ—‹è½¬
            stars.rotation.y += 0.0002;

            // ç‰©ç†æ¨¡æ‹Ÿ
            if (isSimulating && !orbitAnimationPaused) {
                // åŠ¨æ€è°ƒæ•´æ—¶é—´æ­¥é•¿ï¼šæ ¹æ®æœ€å¤§é€Ÿåº¦è°ƒæ•´
                let maxSpeed = 0;
                planetObjs.forEach(({ mesh }) => {
                    const speed = mesh.userData.velocity ? mesh.userData.velocity.length() : 0;
                    maxSpeed = Math.max(maxSpeed, speed);
                });
                
                // æ ¹æ®æœ€å¤§é€Ÿåº¦åŠ¨æ€è°ƒæ•´æ—¶é—´æ­¥é•¿
                let timeStep = 0.5 * timeScale;
                if (maxSpeed > 100) {
                    timeStep = 0.1 * timeScale; // é«˜é€Ÿæ—¶ä½¿ç”¨æ›´å°æ­¥é•¿
                } else if (maxSpeed > 50) {
                    timeStep = 0.2 * timeScale; // ä¸­é€Ÿæ—¶ä½¿ç”¨ä¸­ç­‰æ­¥é•¿
                }
                
                const steps = Math.max(1, Math.floor(1 / timeStep));
                
                for (let step = 0; step < steps; step++) {
                    simulatePhysics(timeStep);
                }
                
                // æ˜Ÿä½“è‡ªè½¬
                planetObjs.forEach(({ mesh }) => {
                    mesh.rotation.y += 0.02 * timeScale;
                    // ç¡®ä¿å¤§å°ä¿æŒä¸º1
                    ensurePlanetScale(mesh);
                });
            }

            // ç›¸æœºè½»å¾®æ‘†åŠ¨æ•ˆæœ - æ›´æ¸©å’Œçš„æ‘†åŠ¨
            if (!isDragging && !isFocusing) {
                const time = Date.now() * 0.0005; // é™ä½æ‘†åŠ¨é¢‘ç‡
                const amplitude = 0.2; // å‡å°æ‘†åŠ¨å¹…åº¦
                camera.position.y += Math.sin(time) * amplitude;
            }

            // æŒç»­è·Ÿè¸ªæ¨¡å¼
            if (isTrackingMode && selectedPlanetForTracking) {
                // ç›®æ ‡ä½ç½®ï¼ˆæ˜Ÿä½“å½“å‰ä½ç½®ï¼‰
                const targetPosition = selectedPlanetForTracking.position.clone();
                
                // è®¡ç®—å½“å‰ç›¸æœºç›¸å¯¹äºç›®æ ‡çš„åç§»
                const currentOffset = camera.position.clone().sub(controls.target);
                
                // æ›´æ–°æ§åˆ¶å™¨ç›®æ ‡ä¸ºæ˜Ÿä½“ä½ç½®
                controls.target.copy(targetPosition);
                
                // ä¿æŒç›¸æœºçš„ç›¸å¯¹ä½ç½®ï¼Œä½†è·Ÿéšç›®æ ‡ç§»åŠ¨
                const newCameraPosition = targetPosition.clone().add(currentOffset);
                camera.position.copy(newCameraPosition);
                
                // æ›´æ–°æ§åˆ¶å™¨
                controls.update();
            } else if (!isFocusing) {
                // åªåœ¨éèšç„¦çŠ¶æ€ä¸‹æ›´æ–°æ§åˆ¶å™¨å’Œç›¸æœºæ‘†åŠ¨
                controls.update();
            }
            
            // æ›´æ–°è½¨è¿¹çº¿ç²—ç»†
            updateTrajectoryLineWidth();
            
            // æ¸…ç†å·²æ¶ˆå¤±çš„è½¨è¿¹çº¿
            cleanupFadedTrajectories();
            
            // å¼ºåˆ¶æ›´æ–°æ‰€æœ‰è½¨è¿¹çº¿å¯è§æ€§
            trajectoryLines.forEach((traj, meshUuid) => {
                if (traj.line && traj.line.material) {
                    traj.line.material.needsUpdate = true;
                    traj.line.material.transparent = true;
                    traj.line.material.depthTest = false;
                    traj.line.material.depthWrite = false;
                    traj.line.material.opacity = 1.2; // å¢å¼ºå‘å…‰æ•ˆæœ
                    traj.line.material.linewidth = 6; // ç¡®ä¿çº¿æ¡ç²—ç»†
                    traj.line.renderOrder = 999;
                    traj.line.frustumCulled = false;
                }
            });
            
            // ç¡®ä¿è½¨è¿¹çº¿åœ¨æœ€åæ¸²æŸ“
            scene.children.sort((a, b) => {
                const aOrder = a.renderOrder || 0;
                const bOrder = b.renderOrder || 0;
                return aOrder - bOrder;
            });
            
            renderer.render(scene, camera);
            updatePlanetLabels();
        }

        // æ·»åŠ CSSåŠ¨ç”»
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            }
            
            @keyframes pulse {
                0% { box-shadow: 0 0 0 0 rgba(37, 117, 252, 0.7); }
                70% { box-shadow: 0 0 0 10px rgba(37, 117, 252, 0); }
                100% { box-shadow: 0 0 0 0 rgba(37, 117, 252, 0); }
            }
            
            #simulate-btn.simulating {
                animation: pulse 2s infinite;
            }
        `;
        document.head.appendChild(style);

        // æ—¶é—´æµé€æ§åˆ¶å˜é‡
        let timeScale = 1;
        // æ—¶é—´æµé€æ§åˆ¶UIé€»è¾‘
        const timeControlPanel = document.createElement('style');
        timeControlPanel.textContent = `
            #time-control-panel {
                position: fixed;
                top: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(30,40,80,0.85);
                color: #fff;
                padding: 16px 32px 14px 32px;
                border-radius: 18px;
                box-shadow: 0 4px 24px rgba(37,117,252,0.18);
                z-index: 2000;
                display: flex;
                flex-direction: column;
                align-items: center;
                font-size: 16px;
                font-family: 'å¾®è½¯é›…é»‘', 'Arial', sans-serif;
                border: 1.5px solid rgba(80,120,255,0.18);
                gap: 10px;
            }
            #time-control-panel input[type="range"] {
                width: 260px;
                margin-top: 6px;
            }
            #time-label {
                font-size: 17px;
                font-weight: 600;
                margin-bottom: 2px;
                letter-spacing: 1px;
            }
            

        `;
        document.head.appendChild(timeControlPanel);
        // äº‹ä»¶ç»‘å®š
        document.getElementById('time-slider').addEventListener('input', function(e) {
            timeScale = parseFloat(this.value);
            document.getElementById('time-label').textContent = `æ—¶é—´æµé€é€Ÿåº¦: ${timeScale.toFixed(1)}x`;
        });

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case ' ':
                    event.preventDefault();
                    toggleSimulation();
                    break;
                case 'r':
                case 'R':
                    // é‡ç½®ç›¸æœºä½ç½®
                    camera.position.set(0, 150, 400);
                    controls.target.set(0, 0, 0);
                    break;
                case 'Delete':
                case 'Backspace':
                    // åˆ é™¤é€‰ä¸­çš„æ˜Ÿä½“
                    if (selectedPlanet) {
                        const index = planetObjs.findIndex(p => p.mesh === selectedPlanet);
                        if (index !== -1) {
                            scene.remove(selectedPlanet);
                            planetNames.delete(planetObjs[index].name);
                            planetObjs.splice(index, 1);
                            updatePlanetList();
                            selectedPlanet = null;
                        }
                    }
                    break;
                case 'Escape':
                    // åœæ­¢è·Ÿè¸ªæ¨¡å¼
                    if (isTrackingMode) {
                        stopTrackingMode();
                    }
                    break;
            }
        });

        // æ·»åŠ è½¨é“æ˜¾ç¤ºåŠŸèƒ½ - 2Dç‰ˆæœ¬
        function createOrbitLine(radius) {
            // ç”¨Lineä»£æ›¿Meshï¼Œç™½è‰²æ›´ç²—
            const segments = 128;
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    Math.cos(theta) * radius,
                    0.1, // å¾®å¾®æŠ¬é«˜ï¼Œé¿å…ä¸åœ°é¢é‡åˆ
                    Math.sin(theta) * radius
                ));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
            const line = new THREE.Line(geometry, material);
            return line;
        }
        
        // æ·»åŠ 3Dè½¨é“æ˜¾ç¤ºåŠŸèƒ½
        function createOrbitLine3D(radius) {
            // åˆ›å»ºç®€åŒ–çš„3Dçƒé¢è½¨é“
            const segments = 32;
            const points = [];
            
            // åˆ›å»ºä¸»è¦çº¬çº¿ï¼ˆæ°´å¹³åœ†ç¯ï¼‰
            for (let lat = -Math.PI/3; lat <= Math.PI/3; lat += Math.PI/6) {
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    const x = Math.cos(theta) * Math.cos(lat) * radius;
                    const y = Math.sin(lat) * radius;
                    const z = Math.sin(theta) * Math.cos(lat) * radius;
                    points.push(new THREE.Vector3(x, y, z));
                }
            }
            
            // åˆ›å»ºä¸»è¦ç»çº¿ï¼ˆå‚ç›´åœ†ç¯ï¼‰
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                for (let lat = -Math.PI/3; lat <= Math.PI/3; lat += Math.PI/6) {
                    const x = Math.cos(theta) * Math.cos(lat) * radius;
                    const y = Math.sin(lat) * radius;
                    const z = Math.sin(theta) * Math.cos(lat) * radius;
                    points.push(new THREE.Vector3(x, y, z));
                }
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x6a11cb, 
                linewidth: 2,
                transparent: true,
                opacity: 0.4
            });
            const line = new THREE.Line(geometry, material);
            return line;
        }

        // æ˜¾ç¤º/éšè—è½¨é“çº¿
        let showOrbits = false;
        const orbitLines = [];
        
        function toggleOrbits() {
            showOrbits = !showOrbits;
            if (showOrbits) {
                planetObjs.forEach(({ mesh }) => {
                    if (mesh.userData.distance > 0) {
                        const orbitLine = createOrbitLine(mesh.userData.distance);
                        orbitLines.push(orbitLine);
                        scene.add(orbitLine);
                    }
                });
            } else {
                orbitLines.forEach(orbit => scene.remove(orbit));
                orbitLines.length = 0;
            }
        }

        // èšç„¦åˆ°æŒ‡å®šæ˜Ÿä½“çš„å‡½æ•°
        function focusOnPlanet(planetMesh) {
            // è®¾ç½®èšç„¦æ ‡å¿—å’Œè·Ÿè¸ªç›®æ ‡
            isFocusing = true;
            selectedPlanetForTracking = planetMesh;
            
            // ç›®æ ‡ä½ç½®ï¼ˆæ˜Ÿä½“ä½ç½®ï¼‰
            const targetPosition = planetMesh.position.clone();
            
            // ä¿æŒå½“å‰ç›¸æœºç›¸å¯¹äºç›®æ ‡çš„åç§»ï¼Œè¿™æ ·ç”¨æˆ·çš„è§’åº¦ä¸ä¼šæ”¹å˜
            const currentOffset = camera.position.clone().sub(controls.target);
            const newCameraPosition = targetPosition.clone().add(currentOffset);
            
            // å¿«é€Ÿç›´æ¥è·³è½¬ï¼Œå‡å°‘è¿‡æ¸¡æ—¶é—´
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 400; // 0.4ç§’å¿«é€Ÿè·³è½¬
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨çº¿æ€§æ’å€¼ï¼Œæ›´ç›´æ¥çš„ç§»åŠ¨
                const easeProgress = progress;
                
                // ç›´æ¥ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼Œä¿æŒå½“å‰è§†è§’è§’åº¦
                camera.position.lerpVectors(startPosition, newCameraPosition, easeProgress);
                controls.target.lerpVectors(startTarget, targetPosition, easeProgress);
                
                // å¼ºåˆ¶æ›´æ–°æ§åˆ¶å™¨ï¼Œç¡®ä¿è§†è§’åŒæ­¥
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    // åŠ¨ç”»å®Œæˆï¼Œå¼€å§‹æŒç»­è·Ÿè¸ª
                    isFocusing = false;
                    startTrackingMode();
                }
            }
            
            animateCamera();
            
            // é«˜äº®æ˜¾ç¤ºè¢«èšç„¦çš„æ˜Ÿä½“
            planetObjs.forEach(({ mesh }) => {
                if (mesh.material) {
                    mesh.material.emissive = new THREE.Color(0x000000);
                    mesh.material.emissiveIntensity = 0;
                }
                mesh.scale.set(1, 1, 1);
            });
            
            // é«˜äº®ç›®æ ‡æ˜Ÿä½“ï¼ˆä¸æ”¹å˜å¤§å°ï¼‰
            if (planetMesh.material) {
                planetMesh.material.emissive = new THREE.Color(0x6a11cb);
                planetMesh.material.emissiveIntensity = 0.5;
            }
            // ç¡®ä¿å¤§å°ä¿æŒä¸º1
            ensurePlanetScale(planetMesh);
        }
        
        // è·Ÿè¸ªæ¨¡å¼å˜é‡
        let selectedPlanetForTracking = null;
        let isTrackingMode = false;
        
        // å¼€å§‹è·Ÿè¸ªæ¨¡å¼
        function startTrackingMode() {
            isTrackingMode = true;
            
            // æ˜¾ç¤ºè·Ÿè¸ªçŠ¶æ€æç¤º
            showTrackingStatus();
            
            // é«˜äº®ç›®æ ‡æ˜Ÿä½“æŒç»­æ˜¾ç¤º
            if (selectedPlanetForTracking && selectedPlanetForTracking.material) {
                selectedPlanetForTracking.material.emissive = new THREE.Color(0x6a11cb);
                selectedPlanetForTracking.material.emissiveIntensity = 0.5;
            }
        }
        
        // åœæ­¢è·Ÿè¸ªæ¨¡å¼
        function stopTrackingMode() {
            isTrackingMode = false;
            selectedPlanetForTracking = null;
            
            // éšè—è·Ÿè¸ªçŠ¶æ€æç¤º
            hideTrackingStatus();
            
            // æ¢å¤æ‰€æœ‰æ˜Ÿä½“å¤–è§‚
            planetObjs.forEach(({ mesh }) => {
                if (mesh.material) {
                    mesh.material.emissive = new THREE.Color(0x000000);
                    mesh.material.emissiveIntensity = 0;
                }
                mesh.scale.set(1, 1, 1);
            });
        }
        
        // æ˜¾ç¤ºè·Ÿè¸ªçŠ¶æ€æç¤ºï¼ˆéšè—ç‰ˆæœ¬ï¼‰
        function showTrackingStatus() {
            // ä¸æ˜¾ç¤ºä»»ä½•æç¤ºï¼Œé™é»˜è·Ÿè¸ª
        }
        
        // éšè—è·Ÿè¸ªçŠ¶æ€æç¤ºï¼ˆéšè—ç‰ˆæœ¬ï¼‰
        function hideTrackingStatus() {
            // ä¸éœ€è¦éšè—ä»»ä½•æç¤º
        }

        // æ·»åŠ è½¨é“åˆ‡æ¢æŒ‰é’®
        const orbitToggle = document.createElement('button');
        orbitToggle.textContent = 'æ˜¾ç¤ºè½¨é“';
        orbitToggle.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(37, 117, 252, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            z-index: 1000;
        `;
        orbitToggle.onclick = () => {
            toggleOrbits();
            orbitToggle.textContent = showOrbits ? 'éšè—è½¨é“' : 'æ˜¾ç¤ºè½¨é“';
        };
        document.body.appendChild(orbitToggle);

        // ä¿®æ”¹GæŒ‰é’®é€»è¾‘
        document.getElementById('change-g-btn').onclick = function() {
            let val = prompt('è¯·è¾“å…¥æ–°çš„ä¸‡æœ‰å¼•åŠ›å¸¸æ•°Gï¼ˆæ­£æ•°ï¼‰', G);
            if (val !== null) {
                let gnum = parseFloat(val);
                if (!isNaN(gnum) && gnum > 0) {
                    G = gnum;
                    alert('Gå·²è®¾ç½®ä¸º ' + G);
                } else {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•°');
                }
            }
        };

        // æ˜Ÿä½“åç§°æ˜¾ç¤º/éšè—é€»è¾‘
        let showPlanetNames = false;
        const planetNameLabels = new Map();
        function createPlanetLabel(mesh, name) {
            if (planetNameLabels.has(mesh.uuid)) return;
            const label = document.createElement('div');
            label.className = 'planet-3d-label';
            label.textContent = name;
            label.style.cssText = 'position:fixed;pointer-events:none;color:#fff;font-weight:bold;font-size:15px;text-shadow:0 2px 8px #000,0 0 2px #6a11cb;z-index:3000;';
            document.body.appendChild(label);
            planetNameLabels.set(mesh.uuid, label);
        }
        function removePlanetLabel(mesh) {
            if (planetNameLabels.has(mesh.uuid)) {
                document.body.removeChild(planetNameLabels.get(mesh.uuid));
                planetNameLabels.delete(mesh.uuid);
            }
        }
        function updatePlanetLabels() {
            // æ¸…ç†æ— æ•ˆlabel
            for (const [uuid, label] of planetNameLabels.entries()) {
                const found = planetObjs.some(({ mesh }) => mesh.uuid === uuid);
                if (!found) {
                    document.body.removeChild(label);
                    planetNameLabels.delete(uuid);
                }
            }
            if (!showPlanetNames) {
                for (const label of planetNameLabels.values()) {
                    label.style.display = 'none';
                }
                return;
            }
            planetObjs.forEach(({ mesh, name }) => {
                let label = planetNameLabels.get(mesh.uuid);
                if (!label) {
                    createPlanetLabel(mesh, name);
                    label = planetNameLabels.get(mesh.uuid);
                }
                label.style.display = 'block';
                // 3Dåæ ‡è½¬2Då±å¹•
                let pos = mesh.position.clone();
                pos.project(camera);
                let x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                let y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                // æ ¹æ®ç›¸æœºè·ç¦»åŠ¨æ€è°ƒæ•´æ ‡ç­¾åç§»
                let camDist = camera.position.distanceTo(mesh.position);
                let offset = Math.max(2, 36 - camDist * 0.08); // è·ç¦»è¶Šè¿œï¼Œåç§»æ›´å°ï¼Œæœ€å°2px
                label.style.left = `${x - label.offsetWidth/2}px`;
                label.style.top = `${y - offset}px`;
                label.textContent = name;
            });
        }
        document.getElementById('toggle-names-btn').onclick = function() {
            showPlanetNames = !showPlanetNames;
            this.textContent = showPlanetNames ? 'éšè—æ˜Ÿä½“åç§°' : 'æ˜¾ç¤ºæ˜Ÿä½“åç§°';
            updatePlanetLabels();
        };

        // sidebaræ”¶èµ·/å±•å¼€é€»è¾‘
        const sidebarPanel = document.getElementById('sidebar-panel');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
        let sidebarCollapsed = false;
        sidebarToggleBtn.onclick = function() {
            sidebarCollapsed = !sidebarCollapsed;
            if (sidebarCollapsed) {
                sidebarPanel.classList.add('collapsed');
                sidebarToggleBtn.innerText = 'â®';
            } else {
                sidebarPanel.classList.remove('collapsed');
                sidebarToggleBtn.innerText = 'â®œ';
            }
        };

        init();
    </script>
</body>
</html>
